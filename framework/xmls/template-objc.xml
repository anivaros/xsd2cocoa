<template xmlns="http://www.example.com/xsd2cocoa"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.example.com/xsd2cocoa template.xsd">
  <format_style type="builtin"/>
  <!-- known simpletypes-->
  <simpletype name="string" objType="NSString" arrayType="NSArray">
    <read>
      <prefix />
      <attribute>self.{{ attribute.variableName }} = [NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding];{% /if %}</attribute>
      <element>
        <![CDATA[{% if element.isSingleValue %}self.{{ element.variableName }} = [NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding];
          {% else %}[{{ element.variableName }}Array addObject:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];{% /if %}]]>
      </element>
      <value>__auto_type value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
        value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        self.value = value;</value>
    </read>
    <write>
        <prefix />
        <attribute>
          <![CDATA[{{ attribute.variableName }}AttrValue = [self.{{ attribute.variableName }} UTF8String];]]></attribute>
        <element>
          <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[{{ element.variableName }}Value UTF8String]);]]></element>
        <value>
          <![CDATA[__auto_type const rc = xmlTextWriterWriteString(writer, (xmlChar*)[self.value UTF8String]);
            if (rc < 0) {
                return NO;
            }]]>
        </value>
    </write>
  </simpletype>
  <simpletype name="any" objType="NSString" arrayType="NSArray">
    <read>
      <prefix />
      <attribute>self.{{ attribute.variableName }} = [NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding];{% /if %}</attribute>
      <element>
        <![CDATA[{% if element.isSingleValue %}self.{{ element.variableName }} = [NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding];
          {% else %}[{{ element.variableName }}Array addObject:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];{% /if %}]]>
      </element>
      <value>__auto_type value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
        value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        self.value = value;</value>
    </read>
    <write>
      <prefix/>
      <attribute>
        <![CDATA[{{ attribute.variableName }}AttrValue = [self.{{ attribute.variableName }} UTF8String];]]>
      </attribute>
      <element>
        <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[{{ element.variableName }}Value UTF8String]);]]>
      </element>
      <value>
        <![CDATA[statusCode = xmlTextWriterWriteString(writer, (xmlChar*)[self.value UTF8String]);
          if (statusCode < 0) return statusCode;]]>
      </value>
    </write>
  </simpletype>
  <simpletype name="anyURI" objType="NSURL" arrayType="NSArray">
    <read>
      <prefix />
      <attribute>self.{{ attribute.variableName }} = [NSURL URLWithString:[NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding]];</attribute>
      <element>
        <![CDATA[{% if element.isSingleValue %}self.{{ element.variableName }} = [NSURL URLWithString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];{% else %}[{{ element.variableName }}Array addObject:[NSURL URLWithString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]]];
          {% /if %}]]>
      </element>
      <value>__auto_type value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
        value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        self.value = [NSURL URLWithString:value];</value>
    </read>
    <write>
      <prefix />
      <attribute>
        <![CDATA[{{ attribute.variableName }}AttrValue = [[self.{{ attribute.variableName }} absoluteString] UTF8String];]]></attribute>
      <element>
        <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[[{{ element.variableName }}Value absoluteString] UTF8String]);]]></element>
      <value>
        <![CDATA[__auto_type const rc = xmlTextWriterWriteString(writer, (xmlChar*)[[self.value absoluteString] UTF8String]);
        if (rc < 0) {
            return NO;
        }]]>
      </value>
    </write>
  </simpletype>
  <simpletype name="boolean" objType="NSNumber"
    arrayType="NSArray">
    <read>
      <prefix></prefix>
      <attribute>self.{{ attribute.variableName }} = @([[NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding] isEqualToString:@"true"]);</attribute>
      <element>
        <![CDATA[self.{{ element.variableName }} = @([[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding] isEqualToString:@"true"]);]]>
      </element>
      <value>__auto_type value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
        value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        self.value = @([value isEqualToString:@"true"]);</value>
    </read>
    <write>
      <prefix />
      <attribute>{{ attribute.variableName }}AttrValue = [self.{{ attribute.variableName }} boolValue] ? "true" : "false";</attribute>
      <element><![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)([{{ element.variableName }}Value boolValue] ? "true" : "false"));]]></element>
      <value>
        <![CDATA[__auto_type const rc = xmlTextWriterWriteString(writer, (xmlChar*)([{{ element.variableName }}Value boolValue] ? "true" : "false"]]);
        if (rc < 0) {
            return NO;
        }]]>
      </value>
    </write>
  </simpletype>
  <simpletype name="integer" objType="NSNumber"
    arrayType="NSArray">
    <read>
      <prefix>__auto_type const numFormatter = [[NSNumberFormatter alloc] init];
        numFormatter.numberStyle = NSNumberFormatterDecimalStyle;
        numFormatter.locale = self.locale;</prefix>
      <attribute>self.{{ attribute.variableName }} = [numFormatter numberFromString:[NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding]];</attribute>
      <element>
        <![CDATA[self.{{ element.variableName }} = [numFormatter numberFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];]]>
      </element>
      <value>__auto_type value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
        value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        self.value = [numFormatter numberFromString:value];</value>
    </read>
    <write>
      <prefix>__auto_type const numFormatter = [[NSNumberFormatter alloc] init];
        numFormatter.numberStyle = NSNumberFormatterDecimalStyle;
        numFormatter.locale = self.locale;</prefix>
      <attribute>{{ attribute.variableName }}AttrValue = [[numFormatter stringFromNumber: self.{{ attribute.variableName }}] UTF8String];</attribute>
      <element>
        <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[[numFormatter stringFromNumber:{{ element.variableName }}Value] UTF8String]);]]></element>
      <value>
        <![CDATA[__auto_type const rc = xmlTextWriterWriteString(writer, (xmlChar*)[[numFormatter stringFromNumber:self.value] UTF8String]);
        if (rc < 0) {
            return NO;
        }]]>
      </value>
    </write>
  </simpletype>
  <simpletype name="decimal" objType="NSNumber"
    arrayType="NSArray">
    <read>
      <prefix>__auto_type const decFormatter = [[NSNumberFormatter alloc] init];
        decFormatter.locale = self.locale;
        decFormatter.numberStyle = NSNumberFormatterDecimalStyle;</prefix>
      <attribute>self.{{ attribute.variableName }} = [decFormatter numberFromString:[NSString stringWithCString: {{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding]];</attribute>
      <element>
        <![CDATA[self.{{ element.variableName }} = [decFormatter numberFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];]]>
      </element>
      <value>__auto_type value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
        value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        self.value = [decFormatter numberFromString:value];</value>
    </read>
    <write>
      <prefix>__auto_type const decFormatter = [[NSNumberFormatter alloc] init];
        decFormatter.locale = self.locale;
        decFormatter.numberStyle = NSNumberFormatterDecimalStyle;</prefix>
      <attribute>{{ attribute.variableName }}AttrValue = [[decFormatter stringFromNumber: self.{{ attribute.variableName }}] UTF8String];</attribute>
      <element>
        <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[[decFormatter stringFromNumber: {{ element.variableName }}Value] UTF8String]);]]>
      </element>
      <value>
        <![CDATA[__auto_type const rc = xmlTextWriterWriteString(writer, (xmlChar*)[[decFormatter stringFromNumber:self.value] UTF8String]);
        if (rc < 0) {
            return NO;
        }]]>
      </value>
    </write>
  </simpletype>
  <simpletype name="dateTime" objType="NSDate" arrayType="NSArray">
    <read>
      <prefix>NSDate *(^dateFromStringBlock)(NSString *dateString) = ^NSDate *(NSString *dateString) {
            __auto_type const sRFC3339DateFormatter = [[NSDateFormatter alloc] init];
            sRFC3339DateFormatter.locale = self.locale;
            sRFC3339DateFormatter.dateFormat = @"yyyy'-'MM'-'dd'T'HH':'mm':'ss.SSSSSSXXXXX";
            NSDate *date = [sRFC3339DateFormatter dateFromString:dateString];
            if (!date) {
                sRFC3339DateFormatter.dateFormat = @"yyyy'-'MM'-'dd'T'HH':'mm':'ssXXXXX";
                date = [sRFC3339DateFormatter dateFromString:dateString];
            }
            if (!date) {
                sRFC3339DateFormatter.dateFormat = @"yyyy'-'MM'-'dd'T'HH':'mm':'ssZ";
                date = [sRFC3339DateFormatter dateFromString:dateString];
            }
            if (!date) {
                sRFC3339DateFormatter.dateFormat = @"yyyy'-'MM'-'dd'T'HH':'mm':'ss";
                date = [sRFC3339DateFormatter dateFromString:dateString];
            }
            return date;
        };</prefix>
      <attribute>
        self.{{ attribute.variableName }} = dateFromStringBlock([NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding]);</attribute>
      <element>
        <![CDATA[{% if element.isSingleValue %}self.{{ element.variableName }} = dateFromStringBlock([NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]);
          {% else %}id {{ element.variableName }}Temp = dateFromStringBlock([NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]);
          [{{ element.variableName }}Array addObject:{{ element.variableName }}Temp];
          {% /if %}]]>
      </element>
      <value>__auto_type value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
        value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        self.value = dateFromStringBlock(value);</value>
    </read>
    <write>
      <prefix>__auto_type const dateFormatter = [[NSDateFormatter alloc] init];
        dateFormatter.locale = self.locale;
        dateFormatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss";</prefix>
      <attribute>{{ attribute.variableName }}AttrValue = [[dateFormatter stringFromDate:self.{{ attribute.variableName }}] UTF8String];</attribute>
      <element>
        <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[[dateFormatter stringFromDate:{{ element.variableName }}Value] UTF8String]);]]>
      </element>
      <value>
        <![CDATA[__auto_type const rc = xmlTextWriterWriteString(writer, (xmlChar*)[[dateFormatter stringFromDate:self.value] UTF8String]);
        if (rc < 0) {
            return NO;
        }]]>
      </value>
    </write>
  </simpletype>
  <simpletype name="date" objType="NSDate" arrayType="NSArray">
    <read>
      <prefix>__auto_type const dateOnlyFormatter = [[NSDateFormatter alloc] init];
        dateOnlyFormatter.dateFormat = @"yyyy-MM-dd";
        dateOnlyFormatter.timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
        dateOnlyFormatter.locale = self.locale;
      </prefix>
      <attribute>self.{{ attribute.variableName }} = [dateOnlyFormatter dateFromString:[NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding]];</attribute>
      <element>
        <![CDATA[{% if element.isSingleValue %}self.{{ element.variableName }} = [dateOnlyFormatter dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];{% else %}[{{ element.variableName }}Array addObject:[dateOnlyFormatter dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]]];
          {% /if %}]]>
      </element>
      <value>__auto_type value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
        value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        self.value = [dateOnlyFormatter dateFromString:value];</value>
    </read>
    <write>
      <prefix>__auto_type const dateOnlyFormatter = [[NSDateFormatter alloc] init];
        dateOnlyFormatter.dateFormat = @"yyyy-MM-dd";
        dateOnlyFormatter.timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
        dateOnlyFormatter.locale = self.locale;
      </prefix>
      <attribute>{{ attribute.variableName }}AttrValue = [[dateOnlyFormatter stringFromDate:self.{{ attribute.variableName }}] UTF8String];</attribute>
      <element>
        <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[[dateOnlyFormatter stringFromDate:{{ element.variableName }}Value] UTF8String]);]]>
      </element>
      <value>
        <![CDATA[__auto_type const rc = xmlTextWriterWriteString(writer, (xmlChar*)[[dateOnlyFormatter stringFromDate:self.value] UTF8String]);
          if (rc < 0) {
              return NO;
          }]]>
      </value>
    </write>
  </simpletype>
  <simpletype name="time" objType="NSDate" arrayType="NSArray">
    <read>
      <prefix>__auto_type const timeFormatter = [[NSDateFormatter alloc] init];
        timeFormatter.dateFormat = @"HH:mm:ss";
        timeFormatter.timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
        timeFormatter.locale = self.locale;
      </prefix>
      <attribute>self.{{ attribute.variableName }} = [timeFormatter dateFromString:[NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding]];</attribute>
      <element>
        <![CDATA[{% if element.isSingleValue %}self.{{ element.variableName }} = [timeFormatter dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]];{% else %}[{{ element.variableName }}Array addObject:[timeFormatter dateFromString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]]];
          {% /if %}]]>
      </element>
      <value>value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
        value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        self.value = [timeFormatter dateFromString:value];</value>
    </read>
    <write>
      <prefix>__auto_type const timeFormatter = [[NSDateFormatter alloc] init];
        timeFormatter.dateFormat = @"HH:mm:ss";
        timeFormatter.timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
        timeFormatter.locale = self.locale;
      </prefix>
      <attribute>{{ attribute.variableName }}AttrValue = [[timeFormatter stringFromDate:self.{{ attribute.variableName }}] UTF8String];</attribute>
      <element>
        <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[[timeFormatter stringFromDate:{{ element.variableName }}Value] UTF8String]);]]>
      </element>
      <value>
        <![CDATA[__auto_type const rc = xmlTextWriterWriteString(writer, (xmlChar*)[[timeFormatter stringFromDate:self.value] UTF8String]);
          if (rc < 0) {
              return NO;
          }]]>
      </value>
    </write>
  </simpletype>
  <simpletype name="base64Binary" objType="NSData" arrayType="NSArray">
    <read>
      <prefix>
      </prefix>
      <attribute>self.{{ attribute.variableName }} = [[NSData alloc] initWithBase64EncodedString:[NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding] options:kNilOptions];</attribute>
      <element>
        <![CDATA[{% if element.isSingleValue %}self.{{ element.variableName }} = [[NSData alloc] initWithBase64EncodedString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding] options:kNilOptions];{% else %}[{{ element.variableName }}Array addObject:[[NSData alloc] initWithBase64EncodedString:[NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding] options:kNilOptions]];
          {% /if %}]]>
      </element>
      <value>__auto_type value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
        value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        self.value = [[NSData alloc] initWithBase64EncodedString:string options:kNilOptions];</value>
    </read>
    <write>
      <prefix/>
      <attribute>
        <![CDATA[{{ attribute.variableName }}AttrValue = [[self.{{ attribute.variableName }} base64EncodedStringWithOptions:kNilOptions] UTF8String];]]>
      </attribute>
      <element>
        <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[[{{ element.variableName }}Value base64EncodedStringWithOptions:kNilOptions] UTF8String]);]]>
      </element>
      <value>
        <![CDATA[statusCode = xmlTextWriterWriteString(writer, (xmlChar*)[[self.value base64EncodedStringWithOptions:kNilOptions] UTF8String]);
          if (statusCode < 0) return statusCode;]]>
      </value>
    </write>
  </simpletype>
  <!--complex type-->
  <complextype objType="NSObject-Subclass" arrayType="NSArray">
    <read>
      <element>
        <![CDATA[{% if element.isSingleValue %}self.{{ element.variableName }} = [[{{ element.codeType }} alloc] initWithReader: reader];{% else %}[{{ element.variableName }}Array addObject: [[{{ element.schemaType.targetClassName }} alloc] initWithReader: reader]];{% /if %}]]>
        </element>
    </read>
    <write>
      <element>
        <![CDATA[
          BOOL result = [{{ element.variableName }}Value writeWithWriter:writer];
          if (!result) {
              return NO;
          }]]>
      </element>
    </write>
    <implementation>
      <!--
Name:          Header
Parameters:    type - the current complex type.
Description:   Work our way through the template CDATA and replace the the {{ }} with the proper values
this will be used to generate the class header files for the complex types.
<Object>.h
-->
      <header extension="h">
        <![CDATA[//------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by XSDConverter.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------

        //
        //  {{  type.targetClassFileName }}.h
        {% if type.schema.hasAnnotations %} //  {{ type.schema.comment }}{% else %}//  {% /if %}
        //  ExecutiveWorkspace
        //
        //  Copyright © 2016 Digital Design. All rights reserved.
        //
        //  This source code was auto-generated by XSDConverter (https://github.com/anivaros/xsd2cocoa).
        //

        #import <Foundation/Foundation.h>
        {% if type.hasComplexBaseClass %}#import "{{ type.baseClass.targetClassFileName }}.h"{% /if %}
        {% for complexType in type.complexTypesInUse %}@class {{ complexType.targetClassName }};
        {% /for %}
        {% if type.hasAnnotations %}/**
        {{ type.comment }} */{% /if %}

        {% for enumType in type.enumTypesInUse %}#import "{{ enumType.enumerationFileName }}.h"
        {% /for %}

        {% if type.hasAnnotations %}/**
        {{ type.comment }}
        */{% /if %}
        @interface {{ type.targetClassName }} : {% if type.hasComplexBaseClass %}{{ type.baseClass.targetClassName }}{% else %}NSObject <NSCopying>{% /if %}

        {% for attribute in type.attributes %}{% if attribute.hasAnnotations %}/**
        {{ attribute.comment }}
        */{% /if %}

        {% if attribute.hasEnumeration %}
        @property (nonatomic, assign) {{ attribute.schemaType.enumerationName }} {{ attribute.variableName }};
        {% else %}
        @property (nonatomic, strong) {{ attribute.codeType }} *{{ attribute.variableName }};
        {% /if %}

        {% /for %}
        {% for element in type.elements %}{% if element.hasAnnotations %}/**
        {{ element.comment }}
        */{% /if %}
        {% if element.hasEnumeration %}
        @property (nonatomic, assign) {{ element.schemaType.enumerationName }} {{ element.variableName }};
        {% else %}
        @property (nonatomic, {% if element.isSingleValue %}strong{% else %}copy{% /if %}) {{ element.codeType }} *{{ element.variableName }};{% /if %}{% /for %}

        {% if type.hasSimpleBaseClass %}/**
        the type's underlying value
        */
        @property (nonatomic{% if type.baseClass.hasEnumeration %}) {{ type.baseClass.enumerationName }} {% else %}, strong) {{ type.baseClass.targetClassName }} *{% /if %}value;
        {% /if %}

        /** Returns a dictionary representation of this class (recursivly making dictionaries of properties) */
        @property (nonatomic, readonly) NSDictionary *dictionary;

        /** Property that sets the NSLocale used by formatters of this type. It defaults to enUSPOSIX */
        @property(nonatomic, strong) NSLocale *locale;
        
        /** The class's initializer used by the reader to build the object structure during parsing (xmlTextReaderPtr at the moment) */
        - (instancetype)initWithReader:(void *)reader NS_DESIGNATED_INITIALIZER;
        
        @end

        @interface {{ type.targetClassName }} (Reading)
        
        /** Method that is overidden by subclasses that want to extend the base type (xmlTextReaderPtr at the moment) */
        - (void)readAttributes:(void *)reader;
        
        @end
        
        @interface {{ type.targetClassName }} (Writing)
        
        /* Method serialize object to xml */
        - (BOOL)writeWithWriter:(void *)writer;
        
        @end]]>
      </header>
      <!--
Name:          Class
Parameters:    type - the current complex type.
Description:   Work our way through the template CDATA and replace the the {{ }} with the proper values
this will be used to generate the class files for the complex types.
-->
      <class extension="m">
        <![CDATA[//------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by XSDConverter.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------

        //
        //  {{  type.targetClassFileName }}.m
        {% if type.schema.hasAnnotations %}//  {{ type.schema.comment }}{% else %}//  {% /if %}
        //  ExecutiveWorkspace
        //
        //  Copyright © 2016 Digital Design. All rights reserved.
        //
        //  This source code was auto-generated by XSDConverter (https://github.com/anivaros/xsd2cocoa).
        //

        #import "{{ type.targetClassFileName }}.h"
        #import <libxml/xmlreader.h>
        #import <libxml/xmlwriter.h>
        {% for complexType in type.complexTypesInUse %}
        #import "{{ complexType.targetClassFileName }}.h"{% /for %}

        {% if type.hasComplexBaseClass %}@implementation {{ type.targetClassName }}{% else %}@implementation {{ type.targetClassName }} {
            NSLocale *_locale;
        }
        
        - (NSLocale *)locale {
            if (!_locale) {
                _locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"];
            }
            return _locale;
        }
        - (void)setLocale:(NSLocale *)locale {
             _locale = locale;
        }{% /if %}

        - (BOOL)writeAttributes:(void *)writer {{% if type.hasBaseClass %}
            [super writeAttributes: writer];{% /if %}
            {{ type.combinedWritePrefixCode }}
            
            {% for attribute in type.attributes %}
            {% if currentLoop.startIndex == currentLoop.currentIndex %}__auto_type rc = 0;{% /if %}
            {% if attribute.writeCodeForAttribute.length %}
            {% if attribute.isOptional %}if (self.{{ attribute.variableName }}) {{% /if %}
                {% if attribute.hasEnumeration %}rc = {{ attribute.writeCodeForAttribute }}{% else %}const char* {{ attribute.variableName }}AttrValue = NULL;
                {{ attribute.writeCodeForAttribute }}
                rc = xmlTextWriterWriteAttribute(writer, (xmlChar*)"{{ attribute.name }}", (xmlChar*){{ attribute.variableName }}AttrValue);{% /if %}
                if (rc < 0) {
                    return NO;
                }
            {% if attribute.isOptional %}}{% /if %}
            {% else %}
            NSLog(@"{{ attribute.variableName }}");
            {% /if %}
            {% /for %}
            return YES;
        }
        
        - (BOOL)writeElements:(xmlTextWriterPtr)writer {{% if type.hasBaseClass %}
            [super writeElements: writer];{% /if %}
            {{ type.combinedWritePrefixCode }}
            
            {% for element in type.elements %}
            {% if element.isSingleValue %}
            {% if element.isOptional %}if (self.{{ element.variableName }}) {{% /if %}
                xmlTextWriterStartElement(writer, (xmlChar*)"{{ element.name }}");
                {% if element.hasEnumeration %}__auto_type const {{ element.variableName }}Value = {{ element.schemaType.enumerationName }}ToString(self.{{ element.variableName }});{% else %}__auto_type const {{ element.variableName }}Value = self.{{ element.variableName }};{% /if %}
                if ({{ element.variableName }}Value != nil) {
                    {{ element.writeCodeForContent }}
                }
                else {
                    {% if element.nillable %}xmlTextWriterWriteAttributeNS(writer, "xsi", "nil", NULL, "true");{% else %}NSLog(@"Error: Required element {{ element.name }} is empty!");{% /if %}
                }
                xmlTextWriterEndElement(writer);
            {% if element.isOptional %}}{% /if %}
            {% else %}
            for (id {{ element.variableName }}Value in self.{{ element.variableName }}) {
                xmlTextWriterStartElement(writer, (xmlChar*)"{{ element.name }}");
                
                {{ element.writeCodeForContent }}
                
                xmlTextWriterEndElement(writer);
            }
            {% /if %}
            {% /for %}
            
            return YES;
        }
        
        - (BOOL)writeWithWriter:(void *)writer {
            if (![self writeAttributes:writer]) {
                return NO;
            }
            
            {% if type.hasSimpleBaseClass %}
            if (self.value){
                {{ type.writeSimpleContent }}
            }{% /if %}
            
            if (![self writeElements:writer]) {
                return NO;
            }
            
            return YES;
        }
        
        /**
        * Name:        readAttributes
        * Parameters:  (void *) - the Libxml's xmlTextReader pointer
        * Returns:     (void)
        * Description: Read the attributes for the current XML element
        */
        - (void)readAttributes:(void *)reader {{% if type.hasComplexBaseClass %}
            [super readAttributes: reader];{% /if %}
            {{ type.combinedReadPrefixCode }}
            {% for attribute in type.attributes %}
            __auto_type {{ attribute.name }}AttrValue = (char *) xmlTextReaderGetAttribute(reader, (xmlChar *)"{{ attribute.name }}");
            if ({{ attribute.name }}AttrValue) {
                {{ attribute.readCodeForAttribute }}
                xmlFree({{ attribute.name }}AttrValue);
            }{% /for %}
        }
        
        /**
        * Name:        initWithReader
        * Parameters:  (void *) - the Libxml's xmlTextReader pointer
        * Returns:     returns the classes created object
        * Description: Iterate through the XML and create the {{ type.targetClassFileName }} object
        */
        - (instancetype)initWithReader:(void *)reader {
            __auto_type const _complexTypeXmlDept = xmlTextReaderDepth(reader);
            {% if type.hasComplexBaseClass %}self = [super initWithReader: reader];{% else %}self = [super init];{% /if %}
            
            /* Customize the object */
            if (self) {
                {{ type.combinedReadPrefixCode }}{% for attribute in type.attributes %}{% if attribute.defaultValue %}
                __auto_type const {{ attribute.name }}AttrValue = (char *) "{{ attribute.defaultValue }}";
                {{ attribute.readCodeForAttribute }}{% /if %}{% /for %}
                {% for element in type.elements %}{% if element.isSingleValue %}{% if element.defaultValue %}
                __auto_type const {{element.name}}ElementValue = (const char *) "{{ element.defaultValue }}";
                if ({{element.name}}ElementValue) {
                {{ element.readCodeForContent }}
                }{% /if %}{% /if %}{% /for %}
                
                {% if type.hasComplexBaseClass %}{% else %}[self readAttributes: reader];{% /if %}
                @autoreleasepool {
                    {% for element in type.elements %}{% if not element.isSingleValue %}__auto_type const {{ element.variableName }}Array = [NSMutableArray array];{% /if %}
                    {% /for %}{% if type.hasComplexBaseClass %}__auto_type _readerOk __attribute__ ((unused)) = 1;{% else %}__auto_type _readerOk __attribute__ ((unused)) = xmlTextReaderRead(reader);{% /if %}
                    __auto_type _currentNodeType __attribute__ ((unused)) = xmlTextReaderNodeType(reader);
                    __auto_type _currentXmlDept = xmlTextReaderDepth(reader);
                    while (_readerOk && _currentNodeType != XML_READER_TYPE_NONE && _complexTypeXmlDept < _currentXmlDept) {
                        __auto_type handledInChild = NO;
                        if (_currentNodeType == XML_READER_TYPE_ELEMENT || _currentNodeType == XML_READER_TYPE_TEXT) {
                            __auto_type const _currentElementName = [NSString stringWithCString:(const char *) xmlTextReaderConstLocalName(reader) encoding:NSUTF8StringEncoding];
                            {% for element in type.elements %}{% if not element.hasAny %}if ([@"{{element.name}}" isEqualToString: _currentElementName]) {
                                {% if element.hasComplexType %}{{ element.readCodeForContent }}
                                handledInChild = YES;
                                {% else %}if (!xmlTextReaderIsEmptyElement(reader)) {
                                    _readerOk = xmlTextReaderRead(reader);
                                    _currentNodeType = xmlTextReaderNodeType(reader);
                                    if (_currentNodeType != XML_READER_TYPE_END_ELEMENT) {
                                        __auto_type const {{element.name}}ElementValue = (const char *) xmlTextReaderConstValue(reader);
                                        if ({{element.name}}ElementValue) {
                                            {{ element.readCodeForContent }}
                                        }
                                        _readerOk = xmlTextReaderRead(reader);
                                        _currentNodeType = xmlTextReaderNodeType(reader);
                                    }
                                }{% /if %}
                            }
                            else {% /if %}{% /for %}{% if type.hasSimpleBaseClass %}if ([@"#text" isEqualToString: _currentElementName]) {
                                __auto_type const contentValue = (const char *) xmlTextReaderConstValue(reader);
                                if (contentValue) {
                                    {{ type.readSimpleContent }}
                                }
                            }
                            else {% /if %}{
                                {% if type.hasAnyElement %}{% for element in type.elements %}{% if element.hasAny %}if (!self.{{element.variableName}} && _currentElementName) {
                                    _currentNodeType = xmlTextReaderNodeType(reader);
                                    if (_currentNodeType != XML_READER_TYPE_END_ELEMENT) {
                                        __auto_type const {{element.name}}ElementValue = (const char *) xmlTextReaderReadOuterXml(reader);
                                        if (strlen({{element.name}}ElementValue)) {
                                            {{ element.readCodeForContent }}
                                        }
                                        _readerOk = strlen({{element.name}}ElementValue) ? xmlTextReaderNext(reader) : xmlTextReaderRead(reader);
                                        _currentNodeType = xmlTextReaderNodeType(reader);
                                        if ({{element.name}}ElementValue) {
                                            xmlFree({{element.name}}ElementValue);
                                        }
                                        handledInChild = YES;
                                        }
                                    }
                                          else if (self.{{element.variableName}}) {
                                              NSAssert(NO, @"Unexpected: %@", _currentElementName);
                                              _readerOk = xmlTextReaderNext(reader);
                                              _currentNodeType = xmlTextReaderNodeType(reader);
                                              handledInChild = YES;
                                          }
                              {% /if %}{% /for %}
                              {% else %}NSAssert(NO, @"Unexpected: %@", _currentElementName);
                              _readerOk = xmlTextReaderNext(reader);
                              _currentNodeType = xmlTextReaderNodeType(reader);
                              handledInChild = YES;
                              {% /if %}}
                        }

                        _readerOk = handledInChild ? xmlTextReaderReadState(reader) : xmlTextReaderRead(reader);
                        _currentNodeType = xmlTextReaderNodeType(reader);
                        _currentXmlDept = xmlTextReaderDepth(reader);
                    }
                    {% for element in type.elements %}
                    {% if element.isSingleValue %}{% else %}if ({{ element.variableName }}Array.count) self.{{ element.variableName }} = {{ element.variableName }}Array.copy;{% /if %}{% /for %}
                }
            }
            return self;
        }

        /**
        * Name:            dictionary
        * Parameters:
        * Returns:         Populated dictionary
        * Description:     Populate the dictionary from the simpleType names within our XSD
        */
        - (NSDictionary *)dictionary {
            /* Initial setup */
            __auto_type const dict = [[NSMutableDictionary alloc] init];
            {% if type.hasComplexBaseClass %}[dict setValuesForKeysWithDictionary:[super dictionary]];{% /if %}
            
            /* Populate the dictionary */
            {% for attribute in type.attributes %}
            if (self.{{ attribute.variableName }}) {
                {% if attribute.hasEnumeration %}[dict setObject:{{ attribute.schemaType.enumerationName }}ToString(self.{{ attribute.variableName }}) forKey:@"{{ attribute.variableName }}"];{% else %}[dict setObject:self.{{ attribute.variableName }} forKey:@"{{ attribute.variableName }}"];{% /if %}
            }
            {% /for %}
            {% for element in type.elements %}
            {% if element.hasComplexType %}
            if (self.{{ element.variableName }}) {
                NSDictionary *{{ element.variableName }}Dict = [self.{{ element.variableName }} valueForKeyPath:@"dictionary"];
                [dict setObject:{{ element.variableName }}Dict forKey:@"{{ element.variableName }}"];
            }
            {% else %}
            if (self.{{ element.variableName }}) {
                {% if element.hasEnumeration %}[dict setObject:{{ element.schemaType.enumerationName }}ToString(self.{{ element.variableName }}) forKey:@"{{ element.variableName }}"];{% else %}[dict setObject:self.{{ element.variableName }} forKey:@"{{ element.variableName }}"];{% /if %}
            }
            {% /if %}
            {% /for %}{% if type.hasSimpleBaseClass %}
            if (self.value) {
                {% if type.baseClass.hasEnumeration %}[dict setObject:{{ type.baseClass.enumerationName }}ToString(self.value) forKey:@"value"];{% else %}[dict setObject:self.value forKey:@"value"];{% /if %}
                }{% /if %}
                
                return dict.copy;
            }
            
            - (id)copyWithZone:(nullable NSZone *)zone {
                __auto_type const copy = [[{{ type.targetClassFileName }} allocWithZone:zone] init];
                if (copy) {
                    {% for attribute in type.attributes %}
                    {% if attribute.hasEnumeration %}copy.{{ attribute.variableName }} = self.{{ attribute.variableName }};
                    {% else %}copy.{{ attribute.variableName }} = [self.{{ attribute.variableName }} copy];{% /if %}
                    {% /for %}
                    {% for element in type.elements %}
                    {% if element.isSingleValue %}
                    {% if element.hasComplexType %}
                    copy.{{ element.variableName }} = [self.{{ element.variableName }} copy];
                    {% else %}
                    {% if element.hasEnumeration %}copy.{{ element.variableName }} = self.{{ element.variableName }};
                    {% else %}copy.{{ element.variableName }} = [self.{{ element.variableName }} copy];{% /if %}
                    {% /if %}
                    {% else %}
                    copy.{{ element.variableName }} = [[NSArray alloc] initWithArray:self.{{ element.variableName }} copyItems:YES];
                    {% /if %}
                    {% /for %}
                    {% if type.hasSimpleBaseClass %}
                    {% if type.baseClass.hasEnumeration %}copy.value = self.value;
                    {% else %}copy.value = [self.value copy];{% /if %}
                    {% /if %}
                }
                return copy;
            }
            
            @end]]>
        </class>
    </implementation>
  <reader>
    <!--
  Name:          Header Element
  Parameters:    type - the current global element type.
  Description:   Work our way through the template CDATA and replace the the {{ }} with the proper values
  this will be used to generate the header file for the elements within our XSD types.
  <Object>+Read.h
  -->
    <header extension="h">
      <![CDATA[/**
          * {{  type.targetClassFileName }}+Read.h
          {% if type.schema.hasAnnotations %} * {{ type.schema.comment }}
          {% /if %}*/
          #import <Foundation/Foundation.h>
          #import "{{ type.targetClassFileName }}.h"
          
          @interface {{ type.targetClassName }} (Read)
          
          /* Reads a xml file specified by the given url and parses it, returning a {{ type.targetClassName }} */
          + ({{ type.targetClassName }} *){{ type.name }}FromURL:(NSURL *)url;
          
          /* Reads a xml file specified by the given file path and parses it, returning a {{ type.targetClassName }} */
          + ({{ type.targetClassName }} *){{ type.name }}FromFile:(NSString *)path;
          
          /* Reads xml text specified by the given data and parses it, returning a {{ type.targetClassName }} */
          + ({{ type.targetClassName }} *){{ type.name }}FromData:(NSData *)data;

          @end]]>
      </header>
    <!--
  Name:           Class Element
  Parameters:     type - the current global element type.
  Description:    Work our way through the template CDATA and replace the the {{ }} with the proper values
  this will be used to generate the header file for the elements within our XSD types.
  <Object>+Read.m
  -->
    <class extension="m">
      <![CDATA[#import "{{ type.targetClassFileName }}+Read.h"
          #import <libxml/xmlreader.h>
          
          #define kGlobalElementNamesArray ((NSArray <NSString *> *)@[@"##elements##"{% for element in type.globalElements %}, @"{{ element.name }}"{% /for %}])
          
          @implementation {{ type.targetClassFileName }} (Read)
          
          /**
          * Name:            FromURL
          * Parameters:      (NSURL *) - the location of the XML file as a NSURL representation
          * Returns:         A generated {{ type.targetClassName }} object
          * Description:     Generate a {{ type.targetClassName }} object from the path
          *                  specified by the user
          */
          + ({{ type.targetClassName }} *){{ type.name }}FromURL:(NSURL *)url {
              {{ type.targetClassName }} *obj = nil;
              xmlTextReaderPtr reader = xmlReaderForFile(url.absoluteString.UTF8String, NULL, (XML_PARSE_NOBLANKS | XML_PARSE_NOCDATA | XML_PARSE_NOERROR | XML_PARSE_NOWARNING));
              int ret;
              if (reader != nil) {
                  //find the correct root
                  do {
                      ret = xmlTextReaderRead(reader);
                      if (ret == XML_READER_TYPE_ELEMENT) {
                              __auto_type const elementName = [NSString stringWithCString: (const char *) xmlTextReaderConstLocalName(reader) encoding:NSUTF8StringEncoding];
                              __auto_type const predicate = [NSPredicate predicateWithFormat:@"SELF IN %@", kGlobalElementNamesArray];
                              if ([predicate evaluateWithObject:elementName]) {
                                  obj = [[{{ type.targetClassName }} alloc] initWithReader: reader];
                                  break;
                              }
                      }
                  } while (ret);
                  xmlFreeTextReader(reader);
              }
              return obj;
          }
          
          /**
          * Name:            FromFile
          * Parameters:      (NSString *) - the location of the XML file as a string
          * Returns:         A generated {{ type.targetClassName }} object
          * Description:     Generate a {{ type.targetClassName }} object from the path
          *                  specified by the user
          */
          + ({{ type.targetClassName }} *){{ type.name }}FromFile:(NSString *)path {
              return [self {{ type.name }}FromURL:[NSURL fileURLWithPath:path]];
          }
          
          /**
          * Name:            FromData:
          * Parameters:      (NSData *)
          * Returns:         A generated {{ type.targetClassName }} object
          * Description:     Generate the {{ type.targetClassName }} object from the NSData
          *                  object generated from the XML.
          */
          + ({{ type.targetClassName }} *){{ type.name }}FromData:(NSData *)data {
              /* Initial Setup */
              {{ type.targetClassName }} *obj = nil;
              /* Create the reader */
              xmlTextReaderPtr reader = xmlReaderForMemory([data bytes], (int)[data length], NULL, NULL, (XML_PARSE_NOBLANKS | XML_PARSE_NOCDATA | XML_PARSE_NOERROR | XML_PARSE_NOWARNING));
              
              /* Ensure that we have a reader and the data within it to generate the object */
              if (reader != nil) {
                  __auto_type const ret = xmlTextReaderRead(reader);
                  if (ret > 0) {
                      obj = [[{{ type.targetClassName }} alloc] initWithReader: reader];
                  }
                  xmlFreeTextReader(reader);
              }
              
              return obj;
          }
          
          @end]]>
      </class>
  </reader>
  <writer>
    <!--
Name:          Header Element
Parameters:    type - the current global element type.
Description:   Work our way through the template CDATA and replace the the {{ }} with the proper values
this will be used to generate the header file for the elements within our XSD types.
<Object>+Write.h
-->
    <header extension="h">
      <![CDATA[/**
        * {{  type.targetClassFileName }}+Read.h
        {% if type.schema.hasAnnotations %} * {{ type.schema.comment }}
        {% /if %}*/
        #import <Foundation/Foundation.h>
        #import "{{ type.targetClassFileName }}.h"
        
        @interface {{ type.targetClassName }} (Write)
        
        /* Method will write object to data. */
        @property (nonatomic, strong, readonly) NSData *toXmlData;

        @end]]>
    </header>
    <!--
Name:           Class Element
Parameters:     type - the current global element type.
Description:    Work our way through the template CDATA and replace the the {{ }} with the proper values
this will be used to generate the header file for the elements within our XSD types.
<Object>+Write.m
-->
    <class extension="m">
      <![CDATA[#import "{{ type.targetClassFileName }}+Write.h"
        #import <libxml/xmlwriter.h>
        
        #define kGlobalElementNamesArray ((NSArray <NSString *> *)@[@"##elements##"{% for element in type.globalElements %}, @"{{ element.name }}"{% /for %}])
        
        @implementation {{ type.targetClassFileName }} (Write)
        
        - (NSData *)toXmlData {
            __auto_type const buf = xmlBufferCreate();
            if (buf == NULL) {
                NSLog(@"Error creating the xml buffer.");
                return nil;
            }
            
            __auto_type const writer = xmlNewTextWriterMemory(buf, 0);
            if (writer == NULL) {
                NSLog(@"Error creating the xml writer.");
                return nil;
            }
            
            __auto_type rc = xmlTextWriterStartDocument(writer, NULL, "UTF-8", NULL);
            if (rc < 0) {
                NSLog(@"Error at xmlTextWriterStartDocument.");
                return nil;
            }
            xmlTextWriterSetIndent(writer, 1);
            xmlTextWriterSetIndentString(writer, (xmlChar *)"\t");
            
            // Serialize object
            xmlTextWriterStartElement(writer, (xmlChar*) kGlobalElementNamesArray.lastObject.UTF8String);
            
            __auto_type const result = [self writeWithWriter:writer];
            
            if (!result) {
                xmlBufferFree(buf);
                xmlCleanupCharEncodingHandlers();
                xmlCleanupParser();
                return nil;
            }
            
            xmlTextWriterEndElement(writer);
            
            rc = xmlTextWriterEndDocument(writer);
            if (rc < 0) {
                NSLog(@"Error at xmlTextWriterEndDocument.");
                return nil;
            }
            
            __auto_type const libxmlVersion = atoi(xmlParserVersion);
            __auto_type const xmlData = [[NSData alloc] initWithBytes:(buf->content) length:(buf->use)];
            
            xmlBufferFree(buf);
            xmlCleanupCharEncodingHandlers();
            xmlCleanupParser();
            
            return xmlData;
        }
        
        @end]]>
    </class>
  </writer>
  </complextype>
  <enumeration objType="NS_ENUM" arrayType="">
    <read>
      <prefix></prefix>
      <attribute>
        <![CDATA[self.{{ attribute.variableName }} = {{ attribute.schemaType.enumerationName }}FromString([NSString stringWithCString:{{ attribute.name }}AttrValue encoding:NSUTF8StringEncoding]);]]>
      </attribute>
      <element>
        <![CDATA[self.{{ element.variableName }} = {{ element.schemaType.enumerationName }}FromString([NSString stringWithCString:{{element.name}}ElementValue encoding:NSUTF8StringEncoding]);]]>
      </element>
      <value>
        <![CDATA[__auto_type value = [NSString stringWithCString:contentValue encoding:NSUTF8StringEncoding];
          value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
          self.value = {{ type.enumerationName }}FromString(value);]]>
      </value>
    </read>
    <write>
      <prefix />
      <attribute>
        <![CDATA[xmlTextWriterWriteAttribute(writer, (xmlChar*)"{{ attribute.name }}", (xmlChar*)[{{ attribute.schemaType.enumerationName }}ToString(self.{{ attribute.variableName }}) UTF8String]);]]>
      </attribute>
      <element>
        <![CDATA[xmlTextWriterWriteString(writer, (xmlChar*)[{{ element.variableName }}Value UTF8String]);]]>
      </element>
      <value>
        <![CDATA[__auto_type const rc = xmlTextWriterWriteString(writer, (xmlChar*)[{{ type.enumerationName }}ToString(self.value) UTF8String]);
        if (rc < 0) {
            return NO;
        }]]>
      </value>
    </write>
    <implementation>
      <header extension="h">
        <![CDATA[#import <Foundation/Foundation.h>

          typedef NS_ENUM(NSInteger, {{ type.enumerationName }}) {
              {% for enumValue in type.enumerationValues %}{{ type.enumerationName }}{{ enumValue }},
              {% /for %}
          };
          NSString *{{ type.enumerationName }}ToString({{ type.enumerationName }} enumType);
          {{ type.enumerationName }} {{ type.enumerationName }}FromString(NSString *enumString);]]>
      </header>
      <class extension="m">
        <![CDATA[#import "{{ type.enumerationFileName }}.h"

          #define k{{ type.enumerationName }}NamesArray ((NSArray <NSString *> *)@[@"##enums##"{% for enumValue in type.enumerationValues %}, @"{{ enumValue }}"{% /for %}])

          NSString *{{ type.enumerationName }}ToString({{ type.enumerationName }} enumType) {
              assert(enumType < k{{ type.enumerationName }}NamesArray.count);
              return [k{{ type.enumerationName }}NamesArray objectAtIndex:enumType+1];
          }
          
          {{ type.enumerationName }} {{ type.enumerationName }}FromString(NSString *enumString) {
              __auto_type const enUSPOSIXLocale = [NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"];
              __auto_type const numFormatter = [[NSNumberFormatter alloc] init];
              numFormatter.locale = enUSPOSIXLocale;
              /*
              if ([numFormatter numberFromString:enumString]) {
                  enumString = [@"Value" stringByAppendingString:enumString];
              }
              */
              __auto_type const enumType = [k{{ type.enumerationName }}NamesArray indexOfObject:enumString];
              assert(enumType != NSNotFound);
              return (enumType != NSNotFound) ? ({{ type.enumerationName }}) enumType-1 : NSNotFound;
          }]]>
      </class>
    </implementation>
  </enumeration>
</template>
